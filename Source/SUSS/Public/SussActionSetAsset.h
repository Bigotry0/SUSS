// 

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "Engine/DataAsset.h"
#include "SussConsideration.h"
#include "SussActionSetAsset.generated.h"


USTRUCT()
struct FSussQuery
{
	GENERATED_BODY()

	/// The tag of the query we want to run
	UPROPERTY(EditDefaultsOnly, meta=(Categories="Suss.Query"))
	FGameplayTag QueryTag;

	/// The max frequency the query will be executed. If less time than this has passed since the last time the query was
	/// executed with the same parameters, the query results will be re-used rather than the query being re-executed
	UPROPERTY(EditDefaultsOnly)
	float MaxFrequency = 0.5f;

	/// Parameters to pass to the query
	UPROPERTY(EditDefaultsOnly)
	TMap<FName, FSussParameter> Params;

};

USTRUCT()
struct FSussActionDef
{
	GENERATED_BODY()
public:
	/// Optional description, for documentation and debugging
	UPROPERTY(EditDefaultsOnly)
	FString Description;

	/// Tag identifying the action which is going to be called
	UPROPERTY(EditDefaultsOnly, meta=(Categories="Suss.Action"))
	FGameplayTag ActionTag;

	/// Parameters to pass to the action (optional)
	/// Often actions get data they need from the Context that is passed to them (generated by queries), but
	/// if you want to pass parameters to the action for this particular action definition, you can do so here
	UPROPERTY(EditDefaultsOnly)
	TMap<FName, FSussParameter> ActionParams;

	/// Queries to run to provide values for the Considerations. Beware: multiple queries that return different
	/// information will geometrically multiply the number of variations that will need to be considered. E.g. if you
	/// run a query for targets, and for locations, the number of variations will be the number of results from each
	/// multiplied together.
	/// You can have multiple queries for the same piece of context (e.g. 2 target queries) and the results will be combined.
	/// If there are no queries, then the considerations will be executed only once with the "Self" context reference only
	/// If you request queries and no results are returned, then this action will be discounted
	UPROPERTY(EditDefaultsOnly)
	TArray<FSussQuery> Queries;

	/// Considerations score the action and will be run as many times as needed by the combination of results from the queries
	UPROPERTY(EditDefaultsOnly)
	TArray<FSussConsideration> Considerations;

	/// Re-weighting applied to the final result of considerations, should you wish to adjust the final value
	UPROPERTY(EditDefaultsOnly)
	float Weight = 1;

	/// Priority group of this action. Actions will be considered in groups according to their priority, with
	/// higher priority (e.g. 20 is higher priority than 50) actions being evaluated first. If any action in a high
	/// priority group scores > 0, that action will be used even if there is potentially a higher scoring action in a
	/// lower priority group. As soon as one action in a priority group scores > 0 then only actions from that group
	/// will be considered for execution.
	UPROPERTY(EditDefaultsOnly)
	int Priority = 100;

	/// The tags required on the agent for this action to be enabled at all
	/// You can have tag tests in considerations as well, but this is a simple way to completely exclude an
	/// action unless ALL these tags are present
	UPROPERTY(EditDefaultsOnly)
	FGameplayTagContainer RequiredTags;

	/// The tags on the agent which stop this action being available at all
	/// You can have tag tests in considerations as well, but this is a simple way to completely exclude an
	/// action if ANY of these tags are present
	UPROPERTY(EditDefaultsOnly)
	FGameplayTagContainer BlockingTags;

	/// Once the decision has been made to perform this action, what additional "Inertia" score to add to it when deciding
	/// whether to continue doing it. This is to avoid the brain flip/flopping on a boundary condition. This inertia
	/// cools down over a period of time so eventually a better scored decision can interrupt it, if the ActionClass
	/// allows interruptions. If the action completes of its own volition, inertia is reset.
	UPROPERTY(EditDefaultsOnly)
	float Inertia = 0.5f;
	
	/// The length of time it takes for the total score (including inertia) from a previously performed action to reduce to 0, if
	/// the action isn't scored higher again. Once a decision is made to run an action, if in future updates the current
	/// action is scored badly, it will be scored higher if the remainder of the old decision score (which reduces over this cooldown)
	/// is higher. This means an action doesn't have to remain viable in its own right to continue, so long as this cooldown
	/// is long enough to keep justifying doing it. If the action *is* scored positively in subsequent updates then that
	/// score will be used if it's higher (but inertia won't be added on continuations, only when first performed)
	UPROPERTY(EditDefaultsOnly)
	float ScoreCooldownTime = 2.0f;

	/// After an action has stopped, either voluntarily completing, or being interrupted, this penalty is subtracted
	/// from future evaluations of the action to discourage repetition. The value cools down over time so that after a while
	/// the action is scored as usual. This penalty will be accumulated if an action is repeated anyway, so for example
	/// a penalty of 0.1 that didn't stop repetition before the cooldown would accumulate to a higher value, increasingly
	/// discouraging further repetition.
	UPROPERTY(EditDefaultsOnly)
	float RepetitionPenalty = 0;
	/// The length of time it takes for the value of RepetitionPenalty to cool down to 0
	UPROPERTY(EditDefaultsOnly)
	float RepetitionPenaltyCooldown = 2;

};
/**
 * An action set is a re-usable collection of actions, to make it quicker & easier to build AIs from pre-built behaviours
 */
UCLASS()
class SUSS_API USussActionSetAsset : public UPrimaryDataAsset
{
	GENERATED_BODY()

protected:
	/// The action definitions
	UPROPERTY(EditDefaultsOnly)
	TArray<FSussActionDef> ActionDefs;

public:
	TArray<FSussActionDef>& GetActions() { return ActionDefs; }

	
};
